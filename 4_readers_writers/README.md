# Readers Vs. Writers

## Task Description

Представим, к примеру, систему бронирования авиабилетов, в которой есть множество соревнующихся процессов, желающих обратиться к ней по чтению и записи. Вполне допустимо наличие нескольких процессов, одновременно считывающих информацию из базы данных (или файлу), но если один процесс обновляет базу данных (проводит операцию записи), никакой другой 
процесс не может получить доступ к базе данных даже для чтения информации. Создать программу, которая будет моделировать читателей и писателей.

## Solution

Для решения задачи необходимо несколько примитивов синхронизации. В частности достаточно было бы одного, аналогичного семафору, который можно было бы заблокировать полностью или частично.
Поскольку Python не предоставляет подобного примитива сам по себе в качестве оного был выбран _CompositeLock класс описанный в файле SharedFile.py.
Данный класс предоставляет интерфейс для композитного захвата/освобождения мьютекса (acquire/release) и для полного захвата/освобождения (lock/unlock).
Все методы класса принимают управляемый мьютекс в виде параметра, сам же класс имеет собственный мьютекс для обеспечения полной блокировки.

Все потоки, которые хотят осуществлять запись должны выполнять полный захват композитного мьютекса, что сделает невозможным его последующие частичные захваты. 
Вызов вернет управление только когда все пользователи выполневшие частичный захват освободят передаваемый мьютекс.

Таким образом все потоки-читатели пользуются интерфейсом частичного захвата/освобождения.
